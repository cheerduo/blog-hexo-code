---
title: 【Linux】孤儿进程和僵尸进程
catalog: true
date: 2018-01-06 12:31:42
subtitle:
header-img:
tags:
- Linux
---

## 1. 前言
+ 子进程由父进程执行`fork`创建而来
+ 子进程和父进程异步运行，即它们无法预知对方行为
+ 当一个进程完成它的工作`exit`之后，其父进程需要调用`wait`或者`waitpid`函数取得子进程的终止状态，然后内核才会将其释放，否则不仅占用内存，还会占用进程号

## 2. 孤儿进程
一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并由init进程对它们完成状态收集工作。

## 3. 僵尸进程
子进程退出后，其进程控制块（PCB）会驻留内存，同时其退出状态会返回给操作系统，由系统发送`SIGCHLD`信号告知父进程，而父进程如果没有调用`wait`或`waitpid`获取子进程的状态信息，那么PCB仍然保存在系统中占用资源。这种进程称之为僵尸进程。

## 4. 解决分析
孤儿进程并没有危害，因为其由init接管，有理由相信其安全性。
而僵尸进程造成的危害上面已经简单提到过了，使用`ps -ef`或`ps aux`可发现其状态为`Z`，其实，僵尸进程是每个进程退出时必经过的状态，也是操作系统提供的能够保证父进程可获取子进程的退出信息的机制，试想一下，如果子进程退出时销毁所有信息，那么即便给父进程发信号父进程也无法再获取到子进程的任何信息了，这是不允许的。
但是`Z`状态仅应作为一个临时状态，父进程收到信号后应该及时处理它，否则当其大量堆积会造成危害。
如果发现当前已经存在大量僵尸进程了，我们可以通过kill掉父进程，使这些僵尸进程变成孤儿进程，从而被init进程接管来进一步处理它们。
想要避免僵尸进程的话，主要有以下两种方法：
+ fork两次，然后销毁一级子进程，使二级子进程成为孤儿进程，进而被init接管
+ 父进程收到`SIGCHLD`信号后使用`wait`或`waitpid`及时处理
